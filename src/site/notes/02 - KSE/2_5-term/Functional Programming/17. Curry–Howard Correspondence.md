---
{"dg-publish":true,"dg-path":"KSE/Functional Programming/17. Curry‚ÄìHoward Correspondence.md","permalink":"/kse/functional-programming/17-curry-howard-correspondence/","tags":["kse"],"created":"2025-04-07T22:48:17.878+03:00","updated":"2025-04-07T23:55:48.651+03:00"}
---


# 17. Curry‚ÄìHoward Correspondence

---

The **[[02 - KSE/2_5-term/Functional Programming/16. Curry Typing\|Curry]]‚ÄìHoward correspondence** (also known as the Curry‚ÄìHoward isomorphism) is a profound insight that draws a **bridge between logic and computation**. It establishes a **direct correspondence** between:

- **Propositions** in logic ‚Üî **Types** in programming
- **Proofs** of propositions ‚Üî **Programs** (or lambda terms)

In essence:

> **‚ÄúA proof is a program, and a proposition is a type.‚Äù**

---

## The Core Idea

Curry‚ÄìHoward reveals a beautiful symmetry:

| Programming (Lambda Calculus)  | Logic (Intuitionistic)               |
| ------------------------------ | ------------------------------------ |
| **Types** in Œª‚Üí                | **Formulas** in Intuitionistic Logic |
| **Terms** (Œª-terms / programs) | **Proofs** of those formulas         |

> [!info] The correspondence says:  
> **Every type** in lambda calculus is a **logical proposition**,  
> and every well-typed **term** is a **proof** of that proposition.

---

## Examples

$$
\vdash \lambda x. x : \alpha \to \alpha
$$

This is the **identity function** in lambda calculus, and it corresponds to the logical tautology:

> ‚ÄúIf $\alpha$ is true, then $\alpha$ is true.‚Äù  
> In logic: $\alpha \to \alpha$

‚úÖ This expression is always valid‚Äî**a tautology**.  
üìå In programming: the identity function is always safe to use.  
üìå In logic: this is always provable.

üß† **Every combinator (no free variables, empty context) in lambda calculus is a tautology in logic.**

Why?

- Because combinators like `I`, `K`, and `S` are **closed, well-typed lambda terms**.
- By Curry‚ÄìHoward, this means they **prove valid logical formulas**.

**I combinator** (`Œªx.x`)

- Type: $\alpha \to \alpha$
- Logic: $\alpha \to \alpha$ (tautology)

**K combinator** (`Œªx.Œªy.x`)

- Type: $\alpha \to (\beta \to \alpha)$
- Logic: If $\alpha$ is true, then $\beta \to \alpha$. Always true.

**S combinator** (`Œªf.Œªg.Œªx. f x (g x)`)

- Type: $(\beta \to \gamma) \to ((\alpha \to \beta) \to (\alpha \to \gamma))$
- Logic: If $\beta \to \gamma$ is true, and $\alpha \to \beta$ is true, then $\alpha \to \gamma$ is true.
- This is a more complex tautology, expressing function application associativity.

---

## Intuitionistic Logic Calculus and Proof Rules

Let‚Äôs explore how logic operates **from a syntactic viewpoint**, using **sequent calculus**‚Äîa way to formally derive logical statements. The whiteboard and the transcript you're working from outline the **basic rules** of implication in **intuitionistic (constructive) logic**, focusing on how **implications are introduced, applied, and reasoned with**.

---

Suppose you have a collection of assumptions (sequentions) like:

$$
\alpha_1, \alpha_2, \dots, \alpha_n
$$

These are your **axioms**, or known truths (called a **context**, often denoted as $\Gamma$). You then **derive** some new conclusion, say:

$$
\Gamma \vdash \beta
$$

This means:

> ‚ÄúFrom assumptions $\Gamma$, I can prove $\beta$.‚Äù

<strong><span style="color: var(--color-aqua);">But here's a catch!</span></strong>

> If your assumptions are contradictory (e.g., $\alpha$ and $\neg\alpha$), you can ‚Äúprove‚Äù anything‚Äîeven nonsense. That‚Äôs a <strong><span style="color: var(--color-red);">broken theory</span></strong>.

üí• So it‚Äôs <strong><span style="color: var(--color-red);">your responsibility</span></strong> to make sure your list of assumptions is **sound and consistent**.

---

## Some Rules of Implication-Only Logic

We‚Äôre working with a **fragment of logic** that deals only with **implications** ($\to$). This system is called **implicational logic**, a part of **intuitionistic logic** (aka constructive logic).

Let‚Äôs build our logic system using **three core rules**:

---

### Rule 1: Axiom (Identity Rule)

If something is assumed, you can use it.

$$
\Gamma, \alpha \vdash \alpha
$$

This simply says:

> ‚ÄúIf $\alpha$ is in your context, then $\alpha$ is provable.‚Äù

‚úÖ This is your **starting point** in any logical derivation.

---

### Rule 2: Modus Ponens (Application Rule)

If you know that **$\alpha \to \beta$** is true, and **$\alpha$** is true,  
then you can conclude **$\beta$**.

$$
\frac{
\Gamma \vdash \alpha \to \beta \quad\quad \Gamma \vdash \alpha
}{
\Gamma \vdash \beta
}
$$

This is the famous rule of **Modus Ponens** (MP):

> ‚ÄúIf you say, ‚Äòif it rains, the street will be wet‚Äô and also know that ‚Äòit rains‚Äô ‚Äî then you can conclude: ‚Äòthe street is wet.‚Äô‚Äù

üí° It's not just _how_ you prove something, but also _what_ you assume in the process.

---

### Rule 3: Implication Introduction

If **assuming $\alpha$** leads you to prove **$\beta$**, then you can conclude the implication **$\alpha \to \beta$** itself.

$$
\frac{
\Gamma, \alpha \vdash \beta
}{
\Gamma \vdash \alpha \to \beta
}
$$

This rule is all about **building functions** (in lambda calculus) or **constructing implications** (in logic):

> ‚ÄúIf assuming $Œ±$ allows me to get to $Œ≤$, then I‚Äôll just write down the implication $Œ± \to Œ≤$.‚Äù

This is **how we define implications** logically.

---

## Transition to Logic

Let‚Äôs now talk about one of the most beautiful insights of the Curry‚ÄìHoward correspondence ‚Äî how we move from **a lambda term** to its **logical meaning**.

Take the following lambda term:

$$

\vdash \lambda x. \lambda y. x


$$

It has the type:

$$

\alpha \to (\beta \to \alpha)


$$

Now here‚Äôs the cool part:

üß† **To get the logical formula**, you just **strip away the lambdas** and keep the type!

> [!note] So:
> **Lambda term:**
>
> $$
> \lambda x. \lambda y. x
> $$
>
> **Type:**
>
> $$
> \alpha \to (\beta \to \alpha)
> $$

The **type alone** becomes your **logical proposition**:

$$

\alpha \to (\beta \to \alpha)


$$

‚úÖ This is a **tautology** in logic ‚Äî it‚Äôs always true.

So the transformation from lambda calculus to logic looks like this:

| Lambda Term                                | Logical Proposition                                                   |
| ------------------------------------------ | --------------------------------------------------------------------- |
| $\lambda x. x$                             | $\alpha \to \alpha$                                                   |
| $\lambda x. \lambda y. x$                  | $\alpha \to (\beta \to \alpha)$                                       |
| $\lambda f. \lambda g. \lambda x. f (g x)$ | $(\beta \to \gamma) \to ((\alpha \to \beta) \to (\alpha \to \gamma))$ |

Just <strong><span style="color: var(--color-red);">remove the lambdas</span></strong>, and what remains is the **logical skeleton** ‚Äî the type tells you the structure of the reasoning.

## The Challenge

Look at this proposition:

$$
\alpha \to (\alpha \to \alpha)
$$

It‚Äôs clearly a tautology in logic. But now try to **construct a lambda term** for it. You might write:

$$
\lambda x.\lambda y. x
$$

This makes sense: we take two arguments of type $\alpha$, and return the first.  
So we have:

$$
\lambda x. \lambda y. x : \alpha \to (\alpha \to \alpha)
$$

‚úÖ Looks good.

But here's the problem:
<strong><span style="color: var(--color-red);">That‚Äôs Not the Only Possibility!</span></strong>

You could also write:

$$
\lambda x. \lambda y. y
$$

Which gives:

$$
\alpha \to (\alpha \to \alpha)
$$

Again! And this is also a valid lambda term, a valid function, but with a <strong><span style="color: var(--color-pink);">different behavior</span></strong>!

And this one:

$$
\lambda x. \lambda y. x \quad \text{(or)} \quad \lambda x. \lambda y. y \quad \text{or anything else that returns a value of type } \alpha
$$

So **multiple different lambda terms** can have the **same type**.

---

## What‚Äôs the Issue?

When going **from lambda ‚Üí logic**, it's straightforward:  
You always get **one formula** ‚Äî the type.

But when going **from logic ‚Üí lambda**, it's **not uniquely determined**.

- There could be **many different terms** with the same type.
- Logic tells you **what is provable**, but it doesn't tell you **how**.

---

## Logic = Specification, Lambda = Implementation

You can think of it this way:

- The formula $\alpha \to (\alpha \to \alpha)$ is like a **spec**:  
  "Given an $\alpha$, produce a function from $\alpha$ to $\alpha$."

- But how you implement that function? That‚Äôs **your choice**.  
  Do you return the first argument? The second? Apply one to another?

That‚Äôs why this direction (Logic ‚Üí Lambda) is trickier.  
You're **constructing a program from a proof**, and there may be **many valid implementations**.

---

Absolutely ‚Äî let's shift the lens to something more **mathematical and familiar**: **theorems and proofs**.

---

## üí° Logic as Theorems, Lambda as Proofs

Imagine you're in a math class.

You see a **statement** on the board:

> ‚ÄúIf a number is even, then doubling it is also even.‚Äù

This statement is a **logical formula**. It‚Äôs a **theorem** ‚Äî something that might be provable.

But how do we prove it? Well, you could:

- Provide an algebraic argument,
- Use induction,
- Or even just give a few examples if your professor is being generous.

Each of these is a **proof** ‚Äî a specific way of showing the theorem is true.

---

üß† <strong><span style="color: var(--color-aqua);">In Curry‚ÄìHoward:</span></strong>

- **Theorem (logical formula)** = **Type**
- **Proof (evidence or argument)** = **Lambda term (program)**

---

**So What‚Äôs the Problem Again?**

When going from:

- **Proof ‚Üí Theorem**:  
  It's like reading a completed proof and saying,  
  "Ah yes, this proves the statement 'if x is even, 2x is even.'"  
  ‚úÖ Clear, one direction, always works.

- **Theorem ‚Üí Proof**:  
  It's like being told:  
  "Here‚Äôs the statement. Now you go and prove it."  
  üò¨ That‚Äôs much harder ‚Äî and you might find **many different proofs**!

---

### üîÅ Multiple Proofs, One Theorem

For example:

**Theorem**:  
$\alpha \to (\alpha \to \alpha)$

There are multiple ‚Äúproofs‚Äù (lambda terms) of it:

- $\lambda x.\lambda y. x$
- $\lambda x.\lambda y. y$
- $\lambda x.\lambda y. (x)$
- ...and so on.

All valid ‚Äî all **prove the same theorem** ‚Äî but they differ in how they do it.

So:

> From **a proof**, you can always find the **theorem** it proves.  
> From **a theorem**, you must **construct a proof** ‚Äî and there may be many ways.

---

### üß™ So What Can We Do With That?

Here's where things get even more interesting:  
Since there can be **many lambda terms** for a single formula, it means:

- We might find **multiple ways to prove the same thing**,
- Some proofs might be **long and complex**,
- Others might be **shorter, more elegant**.

Now imagine you‚Äôre working with a **complex classical theorem** ‚Äî like something from number theory or analysis. You could:

1. **Translate** that theorem into a type (using Curry‚ÄìHoward).
2. Try to **construct lambda terms** (proofs) for it.
3. Maybe even **brute-force** all possible lambda terms of that type.
4. And who knows? You might discover a **simpler proof** you hadn‚Äôt thought of before.

> üß† Proofs become **searchable**.  
> üí° Lambda calculus lets us **enumerate and explore** proofs as **data**.  
> ü§ñ This opens the door to **automated proof discovery** ‚Äî not just verifying, but inventing.

---

### üîÑ Beta Reduction Preserves Meaning

And here's an important technical detail:  
If you find a lambda term **$U$** that has type **$\alpha$**, and you simplify it using **Œ≤-reduction**, the simplified version **$U'$** still has the same type:

$$
U \to_{\beta} U' \quad \Rightarrow \quad U : \alpha \ \Rightarrow \ U' : \alpha
$$

This is a **theorem** in lambda calculus:

> **Œ≤-reduction preserves types.**

So, you can simplify your lambda term without fear ‚Äî it remains a proof of the same theorem.  
That means:

- We can look for **more compact** or **more efficient** terms,
- And still be confident that they prove the same thing.

---

### üí° Final Intuition

Think of it this way:

- A **theorem** is like saying ‚Äúthere exists a path to the mountaintop.‚Äù
- A **lambda term** is the **trail** you choose to hike.
- There might be a steep, winding road‚Ä¶  

But maybe, just maybe, there‚Äôs a **shortcut through the forest** üèûÔ∏è

Curry‚ÄìHoward says:

> "Let‚Äôs map the terrain, explore every route, and maybe discover a **simpler way** to the truth."

---
{"dg-publish":true,"permalink":"/02-kse/2-5-term/functional-programming/08-booleans-and-operators/","tags":["kse"],"created":"2025-02-11T01:16:54.342+02:00","updated":"2025-02-11T01:58:08.677+02:00"}
---


# 08. Booleans and Operators

---

## The Origins of Truth and Falsehood

Imagine a world where every question has only two possible answers:
**Yes** or **No**,
**On** or **Off**,
**True** or **False**.
This is the essence of Boolean logic. Itâ€™s the digital foundation that powers everything from light switches to quantum computers.

But where did it all begin?

Back in the 19th century, an English mathematician named **George Boole** asked a simple but revolutionary question:  
_"Can logic be treated as an algebra?"_

His answer? A resounding _Yes_! He developed a system where logic could be expressed using symbols, operations, and rulesâ€”just like arithmetic. Fast forward to today, and **every computer, smartphone, and digital device runs on his ideas**. Without Boolean logic, there would be no circuits, no programming, no internet!

---

## True and False in Lambda Calculus

In programming and mathematics, we often need a way to **represent** truth and falsehood. Enter **lambda calculus**, a system that distills computation to its purest formâ€”functions and transformations.

In lambda calculus, we define Boolean values as functions:

- True ($\mathbb{T}$) â†’ `Î»x.Î»y.x` (Choose the first argument)
- False ($\mathbb{F}$) â†’ `Î»x.Î»y.y` (Choose the second argument)

At first glance, this might strange... But it's all about interpretation. You can think of it this way:

Imagine you're ordering coffee. You tell the barista:  
_"If I want sugar, give me sugar; otherwise, give me salt."_

Here, you're picking between two options. In lambda calculus, `ğ•‹` always picks the first option (sugar), while `ğ”½` picks the second (salt). **Truth and falsehood are just choices!**

So, basically, you can define $\mathbb{T}$ and $\mathbb{F}$ as you wish, but the most common way is to use the above definitions.

---

## Boolean Operators

Now that we have **True** and **False**, how do we combine them to form logical expressions? Simple: with **Boolean operators**.

### 1. NOT (Negation)

Just flips the value:

- `Â¬` (**Negation**)
  $\neg(\mathbb{T}) = \mathbb{F}$,
  $\neg(\mathbb{F}) = \mathbb{T}$

- In imperative languages:

```scala
 def not(x: Boolean): Boolean =
   if (x) false
   else true
```

So, basically, if `x` is `True`, return `False`; otherwise, return `True`.

- In lambda calculus:

```
 Î»x.x ğ”½ ğ•‹
```

Try it out!

```
 (Î»x.x ğ”½ ğ•‹) ğ•‹ â†’ ğ•‹ ğ”½ ğ•‹ â†’ ((ğ•‹ ğ”½) ğ•‹) â†’ ğ”½
```

### 2. AND (Conjunction)

Only `True` if both inputs are `True`:

- `âˆ§` (**Conjunction**)
  $\mathbb{T} \land \mathbb{T} = \mathbb{T}$,
  $\mathbb{T} \land \mathbb{F} = \mathbb{F}$,
  $\mathbb{F} \land \mathbb{T} = \mathbb{F}$,
  $\mathbb{F} \land \mathbb{F} = \mathbb{F}$

- In imperative languages:

```scala
 def and(x: Boolean, y: Boolean): Boolean =
   if (x) y
   else false
```

- In lambda calculus:

```
 Î»x.Î»y.x y ğ”½
```

Try it out!

$$
(\lambda x.\lambda y.\, x\, y\, \mathbb{F})\, \textcolor{lime}{\mathbb{T}}\, \textcolor{lime}{\mathbb{T}} \to \textcolor{lime}{\mathbb{T}}\, \textcolor{lime}{\mathbb{T}}\, \mathbb{F} \to ((\textcolor{lime}{\mathbb{T}}\, \textcolor{lime}{\mathbb{T}})\, \mathbb{F}) \to \textcolor{lime}{\mathbb{T}}
$$

### 3. OR (Disjunction)

`True` if at least one input is `True`:

- `âˆ¨` (**Disjunction**)
  $\mathbb{T} \lor \mathbb{T} = \mathbb{T}$,
  $\mathbb{T} \lor \mathbb{F} = \mathbb{T}$,
  $\mathbb{F} \lor \mathbb{T} = \mathbb{T}$,
  $\mathbb{F} \lor \mathbb{F} = \mathbb{F}$

- In imperative languages:

```scala
 def or(x: Boolean, y: Boolean): Boolean =
   if (x) true
   else y
```

- In lambda calculus:

$$
\lambda x.\lambda y.\, x\, \mathbb{T}\, y
$$

Try it out!

$$
(\lambda x.\lambda y.\, x\, \mathbb{T}\, y)\, \textcolor{red}{\mathbb{F}}\, \textcolor{lime}{\mathbb{T}} \to \textcolor{red}{\mathbb{F}}\, \mathbb{T}\, \textcolor{lime}{\mathbb{T}} \to ((\textcolor{red}{\mathbb{F}}\, \mathbb{T})\, \textcolor{lime}{\mathbb{T}}) \to \textcolor{lime}{\mathbb{T}}
$$

$$
(\lambda x.\lambda y.\, x\, \mathbb{T}\, y)\, \textcolor{red}{\mathbb{F}}\, \textcolor{red}{\mathbb{F}} \to \textcolor{red}{\mathbb{F}}\, \mathbb{T}\, \textcolor{red}{\mathbb{F}} \to ((\textcolor{red}{\mathbb{F}}\, \mathbb{T})\, \textcolor{red}{\mathbb{F}}) \to \textcolor{red}{\mathbb{F}}
$$

---

## Logical Constructions

So, basically, we already have declared such logical constructions as `NOT`, `AND`, and `OR`, using imperative approaches and lambda calculus. So, we can use these constructions to build more complex logical expressions.

Thus, `if-then-else` constructions can be built like this:

- In imperative languages:

```scala
 def ifThenElse(cond: Boolean, thenBranch: Whatever, elseBranch: Whatever): Whatever =
   if (cond) thenBranch
   else elseBranch
```

- In lambda calculus:

$$
\lambda c.\lambda t.\lambda e.\, c\, t\, e
$$

> [!REMARK]+ Remark
> c â€” condition,
> t â€” then branch,
> e â€” else branch

---

## Pair in Lambda Calculus

Now that we've built **Boolean logic** in lambda calculus, let's step into something equally powerful: **Pairs**.

Imagine you have **two values** that you want to bundle together and pass around as a single unit. In most programming languages, we have **tuples, structs, or objects** for this. But in lambda calculus, we don't have built-in data structuresâ€”we have to build everything from functions!

### Defining a Pair

A **pair** is simply a function that, when given a selector, returns either the first or the second element.

```
PAIR â‰¡ Î»x.Î»y.Î»s. s x y
```

- `x` is the first element.
- `y` is the second element.
- `s` is the selector function that decides which one to return.

Think of a **pair** like a vending machine:

- You insert a coin (the selector function).
- The machine gives you **either the first or second** item, depending on your choice.

### Selecting Values from a Pair

To **retrieve values** from a pair, we define two functions:

#### 1. First (FST)

Returns the first element of the pair:

```
FST â‰¡ Î»p. p ğ•‹
```

#### 2. Second (SND)

Returns the second element of the pair:

```
SND â‰¡ Î»p. p ğ”½
```

### Try It Out!

Let's create a pair `(5, 10)` and extract its values.

#### Step 1: Define the Pair

```
PAIR 5 10
â†’ Î»s. s 5 10
```

#### Step 2: Apply `FST`

```
FST (PAIR 5 10)
â†’ (Î»p. p ğ•‹) (Î»s. s 5 10)
â†’ (Î»s. s 5 10) ğ•‹
â†’ ğ•‹ 5 10
â†’ 5
```

âœ… **Success! We got the first element!**

#### Step 3: Apply `SND`

```
SND (PAIR 5 10)
â†’ (Î»p. p ğ”½) (Î»s. s 5 10)
â†’ (Î»s. s 5 10) ğ”½
â†’ ğ”½ 5 10
â†’ 10
```

âœ… **It works! We retrieved the second element!**

---

### Why Are Pairs Important?

Pairs **unlock** many possibilities in lambda calculus. Once we have pairs, we can:

1. Define **numbers** and **arithmetic** operations...
2. Store **multiple values** together (like a two-element array).
3. Build complex **data structures** (lists, trees, dictionaries).
4. Create **coordinate systems** (like `(x, y)` points in geometry).
5. Represent **key-value pairs** (important for maps and tables).

Just like **Boolean logic was a stepping stone to decision-making**, **pairs are a stepping stone to structured data**. And with structured data, we can **construct entire programming languages!**

---
